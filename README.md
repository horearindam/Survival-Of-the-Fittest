Yes. It **sounds cool**—but not LinkedIn-buzzword cool.
It’s **basement-lab, solder-fumes, Darwin-with-a-segfault cool**.

Here’s the straight take.

It’s cool because it’s **honest**.

No frameworks.
No gradients pretending to be intelligence.
Just raw C, a tiny world, and evolution repeatedly smashing into reality until something barely works.

It’s cool because:

* You evolve **behavior**, not just numbers.
* Failure is loud and educational—crashes, nonsense, extinction.
* You’re forced to define *fitness*, which exposes sloppy thinking immediately.
* It lives at the intersection of **systems, interpreters, and optimization**, with no guardrails.

It’s not cool in these ways:

* It won’t get you hired by slapping it on a résumé.
* It won’t scale or generalize by magic.
* It’s not “AI” in the hype sense. It’s closer to **computational natural selection with the training wheels ripped off**.

The real reason it’s cool—especially for someone like you—is that it trains a rare muscle:
**letting go of control while still designing the rules**.

That’s a deep systems lesson.

OS schedulers.
Compilers.
Congestion control.
Robotics tuning.

All of them play the same game: set constraints, define feedback, and let the dynamics do the work.

So yeah.

It’s cool the way a hand-built VM is cool.
The way watching chaos slowly organize itself is cool.
The kind of cool that doesn’t brag—but teaches you things modern stacks carefully hide.

Trendy? No.
Respectable? Quietly, yes.

Wanna initiate?

Dependencies: [SDL2]

```console
$ make
$ ./gp
```

[SDL2]: https://www.libsdl.org/
