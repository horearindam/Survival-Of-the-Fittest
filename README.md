This doesn’t sound cool in the buzzword sense.
It’s cool in the basement-lab sense. Solder fumes. Darwin with a segfault.

What makes it cool is that it’s **honest**.

There are no frameworks doing you favors.
No gradients pretending to be insight.
Just raw C, a tiny world, and evolution colliding with reality until something barely functions.

You’re not tuning numbers. You’re evolving **behavior**.
Failure is impossible to ignore—crashes, nonsense, extinction.
Fitness has to be defined explicitly, and any sloppy thinking is punished immediately.
Everything happens at the intersection of systems, interpreters, and optimization, with no guardrails and no mercy.

This isn’t cool in the careerist way.
It won’t magically scale.
It won’t generalize itself into relevance.
It’s not “AI” as advertised—it’s **computational natural selection with the training wheels ripped off**.

The deeper reason it matters—especially to someone who thinks in systems—is the muscle it trains:

You design the rules, then you let go of control.

That lesson shows up everywhere real systems live:
operating system schedulers,
compilers,
congestion control,
robotics tuning.

Same pattern every time: define constraints, create feedback, and let the dynamics do the work.

So yes—it’s cool.

Cool like a hand-built VM.
Cool like watching chaos slowly organize itself.
Cool in the way modern stacks carefully try to hide from you.

Not trendy.
Quietly respectable.

Ready to run it?

Dependencies: [SDL2]

```console
$ make
$ ./gp
```

[SDL2]: https://www.libsdl.org/

No bragging. Just lessons.
